"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require("./");
function isPrimitiveType(source) {
    return (typeof source === "string" ||
        typeof source === "number" ||
        typeof source === "boolean" ||
        typeof source === "undefined" ||
        source === null);
}
function isBuiltInType(source) {
    return (source instanceof Date ||
        source instanceof Map ||
        source instanceof Set ||
        source instanceof RegExp);
}
function isSymbol(source) {
    return typeof source === "symbol";
}
function isFunction(source) {
    return typeof source === "function";
}
function isObjectLiteral(source) {
    return source && source.constructor && source.constructor.name === "Object";
}
function isInstance(source) {
    return !isObjectLiteral(source) && typeof source === "object";
}
function serialize(constructors, options) {
    let counter = 0;
    function nextIndex(length = 32) {
        return counter++;
    }
    function findAlreadySerialized(source, alreadySerialized) {
        const existing = alreadySerialized.find(i => i.source === source);
        if (existing) {
            if (typeof existing.result.id === "undefined") {
                existing.result.id = nextIndex();
            }
            return { type: "reference", id: existing.result.id };
        }
    }
    function serializeObjectLiteral(source, alreadySerialized) {
        const existing = findAlreadySerialized(source, alreadySerialized);
        if (existing) {
            return existing;
        }
        else {
            const result = { type: "object", value: {} };
            alreadySerialized.push({ source, result });
            const keys = Object.keys(source);
            for (const key of keys) {
                result.value[key] = doSerialize(source[key], alreadySerialized);
            }
            return result;
        }
    }
    function serializeInstance(source, alreadySerialized) {
        const existing = findAlreadySerialized(source, alreadySerialized);
        if (existing) {
            return existing;
        }
        else {
            const customCtor = constructors.find(c => source instanceof c.ctor);
            if (customCtor) {
                if (customCtor.serializer) {
                    const result = {
                        class: typeof customCtor.name !== "undefined"
                            ? customCtor.name
                            : source.constructor.name,
                        type: "custom",
                        value: undefined
                    };
                    alreadySerialized.push({ source, result });
                    result.value = customCtor.serializer(source, alreadySerialized, (src, alreadySerializedParam) => doSerialize(src, alreadySerializedParam));
                    return result;
                }
                else {
                    const result = {
                        class: typeof customCtor.name !== "undefined"
                            ? customCtor.name
                            : source.constructor.name,
                        props: {},
                        type: "instance"
                    };
                    alreadySerialized.push({ source, result });
                    const keys = Object.keys(source);
                    for (const key of keys) {
                        const val = source[key];
                        result.props[key] = doSerialize(val, alreadySerialized);
                    }
                    return result;
                }
            }
            else {
                throw new Error(`Cannot serialize object with constructor ${source.constructor.name}. Specify a custom serialize function to handle this type.`);
            }
        }
    }
    function serializeArray(source, alreadySerialized) {
        const existing = findAlreadySerialized(source, alreadySerialized);
        if (existing) {
            return existing;
        }
        else {
            const result = { type: "array", items: [] };
            alreadySerialized.push({ source, result });
            for (const item of source) {
                result.items.push(doSerialize(item, alreadySerialized));
            }
            return result;
        }
    }
    function serializeBuiltInType(source, alreadySerialized) {
        const existing = findAlreadySerialized(source, alreadySerialized);
        if (existing) {
            return existing;
        }
        else {
            if (source instanceof Date) {
                return {
                    class: "Date",
                    type: "builtin",
                    value: source.toString()
                };
            }
            else if (source instanceof Map) {
                const result = {
                    class: "Map",
                    type: "builtin",
                    value: []
                };
                alreadySerialized.push({ source, result });
                for (const entry of source.entries()) {
                    const [key, val] = entry;
                    result.value.push([
                        doSerialize(key, alreadySerialized),
                        doSerialize(val, alreadySerialized)
                    ]);
                }
                return result;
            }
            else if (source instanceof Set) {
                const result = {
                    class: "Set",
                    type: "builtin",
                    value: []
                };
                alreadySerialized.push({ source, result });
                for (const entry of source.entries()) {
                    result.value.push(doSerialize(entry[0], alreadySerialized));
                }
                return result;
            }
            else if (source instanceof RegExp) {
                const result = {
                    class: "RegExp",
                    type: "builtin",
                    value: source.toString().slice(1, -1)
                };
                alreadySerialized.push({ source, result });
                return result;
            }
            else {
                return _1.exception(`Unknown builtin type ${source.constructor.name}.`);
            }
        }
    }
    /*
      Types to handle
      export type Serialized =
        | Primitive
        | PrimitiveNonSerializable
        | IObjectLiteral
        | ISpecialType
        | IInstance
        | ICustomSerializedObject
        | IArray
        | IReference;
    */
    function doSerialize(source, alreadySerialized) {
        const result = isPrimitiveType(source)
            ? source
            : isSymbol(source)
                ? options.serializeSymbol
                    ? options.serializeSymbol(source)
                    : {
                        type: "symbol",
                        value: source.toString().slice(7, -1)
                    }
                : isFunction(source)
                    ? options.serializeFunction
                        ? options.serializeFunction(source)
                        : { type: "function", value: source.name }
                    : isBuiltInType(source)
                        ? serializeBuiltInType(source, alreadySerialized)
                        : Array.isArray(source)
                            ? serializeArray(source, alreadySerialized)
                            : isObjectLiteral(source)
                                ? serializeObjectLiteral(source, alreadySerialized)
                                : isInstance(source)
                                    ? serializeInstance(source, alreadySerialized)
                                    : _1.exception(`Cannot serialize ${source.toString()}.`);
        return result;
    }
    return (source) => doSerialize(source, []);
}
exports.default = serialize;
//# sourceMappingURL=serialize.js.map