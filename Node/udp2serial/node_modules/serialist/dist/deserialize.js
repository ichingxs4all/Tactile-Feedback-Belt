"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require("./");
function isPrimitiveType(source) {
    return (typeof source === "string" ||
        typeof source === "number" ||
        typeof source === "boolean" ||
        typeof source === "undefined" ||
        source === null);
}
function isSymbol(source) {
    return !isPrimitiveType(source) && source.type === "symbol";
}
function isFunction(source) {
    return !isPrimitiveType(source) && source.type === "function";
}
function isBuiltInType(source) {
    return !isPrimitiveType(source) && source.type === "builtin";
}
function isArray(source) {
    return !isPrimitiveType(source) && source.type === "array";
}
function isObjectLiteral(source) {
    return !isPrimitiveType(source) && source.type === "object";
}
function isCustomSerializedObject(source) {
    return !isPrimitiveType(source) && source.type === "custom";
}
function isInstance(source) {
    return !isPrimitiveType(source) && source.type === "instance";
}
function isReference(source) {
    return !isPrimitiveType(source) && source.type === "reference";
}
function deserialize(constructors, options) {
    function deserializeBuiltInType(source, alreadyDeserialized) {
        if (source.class === "Date") {
            return new Date(source.value);
        }
        else if (source.class === "Map") {
            const result = new Map();
            alreadyDeserialized.push({ source, result });
            for (const [key, val] of source.value) {
                result.set(doDeserialize(key, alreadyDeserialized), doDeserialize(val, alreadyDeserialized));
            }
            return result;
        }
        else if (source.class === "Set") {
            const result = new Set();
            alreadyDeserialized.push({ source, result });
            for (const entry of source.value) {
                result.add(doDeserialize(entry, alreadyDeserialized));
            }
            return result;
        }
        else if (source.class === "RegExp") {
            const result = new RegExp(source.value);
            alreadyDeserialized.push({ source, result });
            return result;
        }
        else {
            return _1.exception(`Unknown special type with ctor ${source.class}.`);
        }
    }
    function deserializeArray(source, alreadyDeserialized) {
        const result = [];
        alreadyDeserialized.push({ source, result });
        for (const item of source.items) {
            result.push(doDeserialize(item, alreadyDeserialized));
        }
        return result;
    }
    function deserializeObjectLiteral(source, alreadyDeserialized) {
        const result = {};
        alreadyDeserialized.push({ source, result });
        const keys = Object.keys(source.value);
        for (const key of keys) {
            result[key] = doDeserialize(source.value[key], alreadyDeserialized);
        }
        return result;
    }
    function deserializeReference(source, alreadyDeserialized) {
        const item = alreadyDeserialized.find(i => i.source.id === source.id);
        return typeof item !== "undefined"
            ? item.result
            : _1.exception(`Cannot find reference with id ${source.id}.`);
    }
    function deserializeInstance(source, alreadyDeserialized) {
        const customCtor = constructors.find(c => source.class === c.name || source.class === c.ctor.name);
        if (typeof customCtor !== "undefined") {
            const result = new customCtor.ctor();
            alreadyDeserialized.push({ source, result });
            const keys = Object.keys(source.props);
            for (const key of keys) {
                const val = source.props[key];
                result[key] = doDeserialize(val, alreadyDeserialized);
            }
            return result;
        }
    }
    function deserializeCustomSerializedObject(source, alreadyDeserialized) {
        const customCtor = constructors.find(c => source.class === c.name || source.class === c.ctor.name);
        if (customCtor && customCtor.deserializer) {
            const result = customCtor.deserializer(source.value, source, alreadyDeserialized, (src, alreadyDeserializedParam) => doDeserialize(src, alreadyDeserializedParam));
            return result;
        }
        else {
            _1.exception(`Missing deserializer for custom deserialized object of type '${source.type}' and ctor '${source.class}'.`);
        }
    }
    /*
      Types to handle
      export type Serialized =
        | Primitive
        | PrimitiveNonSerializable
        | IObjectLiteral
        | IBuiltIn
        | IInstance
        | ICustomSerializedObject
        | IArray
        | IReference;
    */
    function doDeserialize(source, alreadyDeserialized) {
        const result = isPrimitiveType(source)
            ? source
            : isSymbol(source)
                ? options.deserializeSymbol
                    ? options.deserializeSymbol(source.value)
                    : Symbol(source.value)
                : isFunction(source)
                    ? options.deserializeFunction
                        ? options.deserializeFunction(source.value)
                        : source.value
                    : isBuiltInType(source)
                        ? deserializeBuiltInType(source, alreadyDeserialized)
                        : isArray(source)
                            ? deserializeArray(source, alreadyDeserialized)
                            : isObjectLiteral(source)
                                ? deserializeObjectLiteral(source, alreadyDeserialized)
                                : isCustomSerializedObject(source)
                                    ? deserializeCustomSerializedObject(source, alreadyDeserialized)
                                    : isInstance(source)
                                        ? deserializeInstance(source, alreadyDeserialized)
                                        : isReference(source)
                                            ? deserializeReference(source, alreadyDeserialized)
                                            : _1.exception(`Unable to serialize object ${source}.`);
        return result;
    }
    return (source) => doDeserialize(source, []);
}
exports.default = deserialize;
//# sourceMappingURL=deserialize.js.map